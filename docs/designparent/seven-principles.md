#### 设计模式的七大原则

##### 1、单一职责

###### **定义**

　　一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。

###### **分析**

　　一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。

　　类的职责主要包括两个方面：数据职责和行为职责，数据职责通过其属性来体现，而行为职责通过其方法来体现。

　　单一职责原则是实现高内聚、低耦合的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。

##### 2、开闭原则（Open Close Principle）

###### **定义**

　　一个软件实体应当对扩展开放，对修改关闭。也就是说在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。

###### **分析**

　　抽象化是开闭原则的关键。

　　开闭原则还可以通过一个更加具体的“对可变性封装原则”来描述，对可变性封装原则(EVP)要求找到系统的可变因素并将其封装起来。

##### 3、里氏代换原则（Liskov Substitution Principle）

###### **定义**

　　所有引用基类（父类）的地方必须能透明地使用其子类的对象。

###### **分析**

　　里氏代换原则可以通俗表述为：在软件中如果能够使用基类对象，那么一定能够使用其子类对象。把基类都替换成它的子类，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。

　　里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。

　　使用里氏代换原则需要注意：

　　　　1.子类的多有方法必须在父类中声明，或者子类必须实现父类中声名的所有方法。

　　　　2.尽量把父类设计成抽象类或接口，让子类继承父类或实现父接口。增加一个新功能时，通过增加一个新的子类来实现。

　　　　3.java语言编译时会检查一个程序是否符合里氏代换原则，但只是一个语法意义上的检查，有局限性。



##### 4、依赖倒转原则（Dependence Inversion Principle）

###### **定义**

　　高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。

###### **分析**

　　简单来说，依赖倒转原则就是指：代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程。

　　实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。

###### **类之间的耦合**

　　　　•零耦合关系

　　　　•具体耦合关系

　　　　•抽象耦合关系

　　依赖倒转原则要求客户端依赖于抽象耦合，以抽象方式耦合是依赖倒转原则的关键。里氏代换原则时依赖倒转原则的基础。

###### **依赖注入**

　　就是将一个类的对象传入另一个类，注入式应该尽量注入父类对象，而在程序运行时再通过子类对象来覆盖父类对象。

　　•<u>构造注入</u>(Constructor Injection)：通过构造函数注入实例变量。

　　•<u>设值注入</u>(Setter Injection)：通过Setter方法注入实例变量。

　　•<u>接口注入</u>(Interface Injection)：通过接口方法注入实例变量。

##### 5、接口隔离原则（Interface Segregation Principle）

###### **定义**

　　客户端不应该依赖那些它不需要的接口。

　　一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。

###### **分析**

　　接口隔离原则是指使用多个专门的接口，而不使用单一的总接口。每一个接口应该承担一种相对独立的角色，不多不少，不干不该干的事，该干的事都要干。

　　(1) 一个接口就只代表一个角色，每个角色都有它特定的一个接口，此时这个原则可以叫做“角色隔离原则”。 

　　(2) 接口仅仅提供客户端需要的行为，即所需的方法，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。

　　使用接口隔离原则拆分接口时，首先必须满足单一职责原则，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。

> 内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系；
>
> 耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。

　　可以在进行系统设计时采用定制服务的方式，即为不同的客户端提供宽窄不同的接口，只提供用户需要的行为，而隐藏用户不需要的行为。

##### 6、迪米特法则（最少知道原则）（Demeter Principle）

###### **定义**

　　(1) 不要和“陌生人”说话。

　　(2) 只与你的直接朋友通信。

　　(3) 每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。

###### **分析**

　　简单地说，迪米特法则就是指一个软件实体应当尽可能少的与其他实体发生相互作用。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。

　　在迪米特法则中，对于一个对象，其朋友包括以下几类：

　　(1) 当前对象本身(this)；

　　(2) 以参数形式传入到当前对象方法中的对象；

　　(3) 当前对象的成员对象；

　　(4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；

　　(5) 当前对象所创建的对象。

　　任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。

　　迪米特法则可分为狭义法则和广义法则。在狭义的迪米特法则中，如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。。

##### 7、合成复用原则（Composite Reuse Principle）

###### **定义**

　　尽量使用对象组合，而不是继承来达到复用的目的。

###### **分析**

　　合成复用原则就是指在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。

　　在面向对象设计中，可以通过两种基本方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承。

　　•继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用 ）

　　•组合/聚合复用：耦合度相对较低，选择性地调用成员对象的操作；可以在运行时动态进行。（“黑箱”复用 ）

　　组合/聚合可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。